# 콘서트 대기열 시스템 동시성 문제 보고서

---

### 목차
1. [발생 가능한 동시성 이슈 분석](#1-발생-가능한-동시성-이슈-분석)
    1) [좌석 예약 기능](#1--좌석-예약-기능)
    2) [잔액 충전 기능 (유저 잔액 관련 동시성 이슈)](#2--잔액-충전-기능--유저-잔액-관련-동시성-이슈-)
    3) [좌석 예약 건 결제](#3--좌석-예약-건-결제)
2. [해결방안 및 의사결정](#2-해결-방안-및-의사결정)
3. [참고문헌](#3-참고-문헌)

---

# 1. 발생 가능한 동시성 이슈 분석
## 1) 좌석 예약 기능
- 동시에 여러 사용자가 동일한 좌석에 대해 예약 요청을 했을 때, 좌석이 중복으로 배정되지 않아야 한다.

### 동시성 이슈가 발생할 수 있는 시나리오
- 동일한 좌석에 대해 다수의 사용자가 동시에 예약 요청을 보낸다.
- 상세 시나리오 예시
  1. 사용자 A와 B가 동시에 같은 좌석에 대해 예약 요청을 보낸다.
  2. 사용자 A와 B는 점유되지 않은 좌석 정보를 조회한다.
  3. 사용자 A의 요청이 처리되고, 좌석이 A에게 배정된다.
  4. 사용자 B의 요청이 처리되고, 좌석이 B에게 배정된다.
  5. 결과적으로 같은 좌석이 두 사용자에게 배정되어 중복으로 배정된다.

- 따라서 좌석 예약 기능에서는 동시성 이슈를 고려하여 하나의 좌석은 한 사용자에게만 배정되도록 해야 한다.

## 2) 잔액 충전 기능 (유저 잔액 관련 동시성 이슈)
- 동일한 사용자에 대한 잔액 충전 요청이 동시에 발생할 때, 모든 요청이 정상적으로 처리되어야 한다.
- 동일한 사용자에 대한 잔액 충전 요청, 결제 요청이 동시에 발생할 때, 모든 요청이 정상적으로 처리되어야 한다.

### 동시성 이슈가 발생할 수 있는 시나리오
1) 사용자 A가 두 번의 잔액 충전 요청을 동시에 보냄 (예: 여러 디바이스에서 동시 요청 발생).
- 단계별 이슈 발생 과정 
  1. 첫 번째 충전 요청이 시작
     - 첫 번째 요청에서 사용자의 현재 잔액을 조회한다.
     - 조회한 잔액을 바탕으로 충전 로직을 실행하여 잔액을 업데이트한다.
  2. 두 번째 충전 요청이 시작 
     - 두 번째 요청도 동시에 사용자의 현재 잔액을 조회. 
     - 첫 번째 요청과 동일한 잔액을 조회하게 되어, 두 요청이 서로의 작업 결과를 반영하지 못한 상태로 충전을 진행한다.
  3. 충전 처리 완료 
     - 두 요청 모두 충전 로직을 각각 실행하여, 잔액이 정확하게 업데이트되지 않거나 일관성 문제가 발생할 수 있다.
- 이슈 : 두 요청이 동시에 처리되며 충전이 정상적으로 이루어지지 않거나, 예상보다 적게 충전되는 문제가 발생할 수 있다.


2) 사용자 A가 잔액 충전 요청을 보내고, 동시에 결제 요청을 보냄.
- 단계별 이슈 발생 과정 
  1. 충전 요청이 시작
     - 충전 요청에서 사용자의 현재 잔액을 조회한다.
     - 조회한 잔액을 바탕으로 충전 로직을 실행하여 잔액을 업데이트한다.
     - 충전 처리 완료
  2. 결제 요청이 시작 
     - 결제 요청에서 사용자의 현재 잔액을 조회. 
     - 충전 요청과 동일한 잔액을 조회하게 되어, 두 요청이 서로의 작업 결과를 반영하지 못한 상태로 결제를 진행한다.
     - 결제 처리 완료
- 이슈: 두 요청 모두 충전 로직을 각각 실행하여, 잔액이 정확하게 업데이트되지 않거나 일관성 문제가 발생할 수 있다.


## 3) 좌석 예약 건 결제
- 동일한 좌석 예약 건에 대한 결제 요청이 동시에 발생할 때, 중복 결제가 발생하지 않아야 한다.
- 좌석 예약 결제 요청과 스케줄러에 의한 예약 취소 요청이 동시에 발생할 경우, 오직 하나의 요청만 성공해야 한다.


### 동시성 이슈가 발생할 수 있는 시나리오
**1) 사용자 A가 두 번의 결제 요청을 동시에 보냄**
- 단계별 이슈 발생 과정
    1. 첫 번째 결제 요청이 시작
        - 예약 건을 조회하여 예약 상태를 확인 (예약 상태가 변경되지 않은 상태)
        - 사용자의 잔액을 차감
        - 결제 처리 완료
    2. 두 번째 결제 요청이 시작
        - 예약 건을 조회하여 예약 상태를 확인 (예약 상태가 변경되지 않은 상태)
        - 사용자의 잔액을 차감
        - 결제 처리 완료
- 이슈
    - 두 요청이 동시에 성공적으로 처리되며 사용자의 잔액이 두 번 차감될 수 있다.

**2) 사용자 A가 좌석 예약 결제 요청을 보내고, 동시에 스케줄러에 의한 예약 취소 요청이 발생**
- 단계별 이슈 발생 과정
    1. 결제 요청이 시작
        - 예약 건을 조회하여 예약 상태를 확인 (예약 상태가 변경되지 않은 상태)
        - 사용자의 잔액을 차감
        - 결제 처리 완료
    2. 스케줄러에 의한 예약 취소 요청이 시작
        - 예약 건을 조회하여 예약 상태를 확인 (예약 상태가 변경되지 않은 상태)
        - 예약 취소 처리 완료
- 이슈
    - 두 요청이 동시에 성공적으로 처리되며 사용자의 잔액이 차감되어 결제 내역이 생기며, 예약이 취소될 수 있다.

---



# 2. 해결 방안 및 의사결정

## 1) 좌석 예약 기능
- 시나리오: `동일한 좌석에 대해 다수의 사용자가 동시에 예약 요청을 보낸다.`
- 발생 가능성 : `높음`
- 재처리 필요 여부 : `불필요`
- 동시성 이슈: `동일한 좌석이 중복으로 배정되는 문제가 발생할 수 있다.`

### 해결방안 1 - 낙관적 락 (Optimistic Lock)

---
- 구현 난이도 : `쉬움`
- 동시성 이슈가 발생할 경우, 버전이 일치하지 않아 업데이트가 실패하고 예외가 발생한다.
- 하나의 좌석은 한 번만 예약되어야 하므로 실패된 요청은 재처리할 필요가 없다.
- 잦은 충돌이 발생하는 경우(인기 있는 좌석) 에는 트랜잭션 롤백 자원이 낭비될 수 있다.
- 좌석 예약 여부를 미리 알지 못하고 커밋 시점에 확인할 수 있다.


### 테스트 수행 결과
- TEST CASE : 동일한 좌석에 대해 500개의 요청이 동시에 발생하는 경우 하나의 요청만 성공하고 나머지는 실패해야 한다.

`@Transactional` 을 UseCase 에 건 경우
```
전체 테스트 수행 시간 (ms): 259
최소 소요 작업 시간 (ms): 1
최대 소요 작업 시간 (ms): 254
평균 소요 작업 시간 (ms): 121.72735303232322
```

`@Transactional` 을 Service 에 건 경우
```
전체 테스트 수행 시간 (ms): 274
최소 소요 작업 시간 (ms): 1
최대 소요 작업 시간 (ms): 197
평균 소요 작업 시간 (ms): 64.00597186947792
```

<br>

### 해결방안 2 - 비관적 락 (Pessimistic Lock)

---
- 구현 난이도 : `쉬움`
- X-LOCK 을 사용하여 동시성 문제를 해결
- 읽기 작업에도 락을 걸기 때문에 성능 저하가 발생할 수 있다.
- 인기가 없는 좌석은 충돌 빈도가 적기 때문에 불필요한 자원 낭비가 발생할 수 있다.


### 테스트 수행 결과
- TEST CASE : 동일한 좌석에 대해 500개의 요청이 동시에 발생하는 경우 하나의 요청만 성공하고 나머지는 실패해야 한다.

`@Transactional` 을 UseCase 에 건 경우
```
전체 테스트 수행 시간 (ms): 560
최소 소요 작업 시간 (ms): 4
최대 소요 작업 시간 (ms): 544
평균 소요 작업 시간 (ms): 310.800112518
```

`@Transactional` 을 Service 에 건 경우
```
전체 테스트 수행 시간 (ms): 558
최소 소요 작업 시간 (ms): 3
최대 소요 작업 시간 (ms): 538
평균 소요 작업 시간 (ms): 324.276703616
```

<br>

### 해결방안 3 - 분산락 (Distributed Lock) - Redission

---
- 구현 난이도 : `어려움`
- 한 번에 여러 좌석에 대한 예약 요청을 할 수 있기 때문에 여러 좌석에 대한 멀티 분산락을 사용하여 동시성 문제를 해결
- 락을 점유해야 트랜잭션이 시작되기 때문에 사용자가 몰리는 좌석 예약의 경우에 DB 부하를 줄일 수 있다. 하지만 락을 대기하는 시간이 길어질 수 있다.
- 분산락을 사용하여 여러 인스턴스 간에 동시성 문제를 해결할 수 있다.
- SpinLock 방식의 Lattuce 대신 Pub/Sub 방식의 `Redission`을 사용하여 분산락을 구현
- redis 를 이용해 분산락을 구현한 이유
  - 메모리 기반의 데이터 저장소로 빠른 속도로 데이터를 처리할 수 있다.
  - Pub/Sub 방식을 지원하여 여러 인스턴스 간의 동기화를 쉽게 구현할 수 있다.
  - 분산 환경에서도 안정적으로 동작할 수 있다.
  - 다양한 데이터 구조를 지원하므로, 다양한 용도로 사용할 수 있다.


### 테스트 수행 결과
- TEST CASE : 동일한 좌석에 대해 500개의 요청이 동시에 발생하는 경우 하나의 요청만 성공하고 나머지는 실패해야 한다.

```
전체 테스트 수행 시간 (ms): 1479
최소 소요 작업 시간 (ms): 9
최대 소요 작업 시간 (ms): 1406
평균 소요 작업 시간 (ms): 818.597079998
```

<br>

### 테스트 수행 시간 한 눈에 보기
| 해결방안 | 전체 테스트 수행 시간 (ms) | 최소 소요 작업 시간 (ms) | 최대 소요 작업 시간 (ms) | 평균 소요 작업 시간 (ms) |
| --- | --- | --- | --- | --- |
| 낙관적 락 | 259 | 1 | 254 | 121.72735303232322 |
| 비관적 락 | 560 | 4 | 544 | 310.800112518 |
| 분산락 | 1479 | 6 | 1406 | 818.597079998 |

<br>

### 결론(의사결정)

`낙관적 락`을 사용하여 동시성 문제를 해결

- 낙관적 락을 통한 동시성 관리 
  - 좌석 예약 기능의 경우, 낙관적 락을 사용하는 것이 적합합니다. 여러 사용자가 동시에 동일 좌석에 대해 예약을 시도할 때, 하나만 성공해도 되어 재처리 로직이 필요 없기 때문에 낙관적 락이 효율적입니다.
  - 반면, 비관적 락은 읽기 작업에도 락을 걸기 때문에 성능이 저하될 수 있습니다.
  - 분산락의 경우 다중 DB 인스턴스 간에 동시성 문제를 해결할 수 있지만, 현재는 단일 DB 인스턴스에서 운영되고 있으므로 낙관적 락만으로 충분합니다.
  - 분산 락이나 비관적 락을 사용할 경우 동일한 자원에 대한 요청이 있을 때 한 명의 사용자만 성공하고 나머지는 실패하게 되어, 나머지 사용자에게 불필요한 대기 시간이 발생할 수 있습니다. 이러한 대기 시간은 사용자 경험을 해칠 수 있으며, 사용자는 대기 후 실패했다는 결과를 받게 되어 사용자 경험을 해칠 수 있습니다. 따라서 요청이 많은 상황에서는 즉각적인 피드백을 제공하는 낙관적 락을 사용하는 것이 더 적합하다고 판단하였습니다.
  
- DB 부하와 낙관적 락의 한계
  - 낙관적 락은 단기간 내에 여러 DB 트랜잭션이 발생할 경우 부하가 증가할 수 있습니다. 분산락을 함께 사용하여 요청을 분산하면 단기적으로 발생하는 DB 트래픽을 조절할 수 있습니다.

- 대기열 시스템으로 부하 관리 가능
  - 앞단에서 대기열 시스템을 운영하면, 분산락을 추가하지 않아도 대기열이 부하를 조절해 줍니다. 대기열 시스템이 이미 트래픽을 선별하고 순차적으로 처리하므로, 낙관적 락만으로도 충분히 동시성 문제를 해결할 수 있습니다.
  - 따라서, 대기열을 통해 부하가 이미 분산되는 상황이므로 추가적인 분산락은 불필요합니다. 최종적으로 낙관적 락을 통해 좌석 예약 시스템의 동시성 이슈를 해결하는 방향으로 결정하였습니다.



---

## 2) 잔액 충전 기능(유저 잔액 관련 동시성 이슈)
- 시나리오: `동일한 사용자에 대한 잔액 충전 및 결제 요청이 동시에 발생한다.`
- 발생 가능성 : `낮음`
- 재처리 필요 여부 : `필요`
- 동시성 이슈: `사용자의 잔액이 정확하게 업데이트되지 않거나 일관성 문제가 발생할 수 있다.`

<br>

### 해결방안 1 - 낙관적 락 (Optimistic Lock)

---
- 구현 난이도 : `쉬움`
- 모두 성공 처리가 되어야 하기 때문에 재처리 로직이 필요하다. (retry count 2로 설정)
- 요청이 많아질 경우, 재처리를 하더라도 성공하지 못할 수 있다.
- 재시도 로직을 통해 성공할 때까지 요청을 반복하게 되면 성능이 저하될 수 있다.


### 테스트 수행 결과
- TEST CASE : 동일한 사용자에 대한 충전 요청이 동시에 5건 발생하는 경우 모두 성공해야 한다.
```
전체 테스트 수행 시간 (ms): 346
최소 소요 작업 시간 (ms): 20
최대 소요 작업 시간 (ms): 345
평균 소요 작업 시간 (ms): 173.01646680000002
```

- TEST CASE : 동일한 사용자에 대한 충전/결제 요청이 동시에 4건 발생하는 경우 모두 성공해야 한다. (충전 2건, 결제 2건)
```
전체 테스트 수행 시간 (ms): 238
최소 소요 작업 시간 (ms): 20
최대 소요 작업 시간 (ms): 237
평균 소요 작업 시간 (ms): 129.57480175
```

<br>

### 해결방안 2 - 비관적 락 (Pessimistic Lock)

---
- 구현 난이도 : `쉬움`
- 읽기 작업에도 락을 걸기 때문에 성능 저하가 발생할 수 있다.
- 요청이 많아질 경우, 락을 대기하는 시간이 길어질 수 있다.
- 모두 성공 처리를 보장할 수 있다.


### 테스트 수행 결과
- TEST CASE : 동일한 사용자에 대한 충전 요청이 동시에 5건 발생하는 경우 모두 성공해야 한다.

```
전체 테스트 수행 시간 (ms): 17
최소 소요 작업 시간 (ms): 12
최대 소요 작업 시간 (ms): 16
평균 소요 작업 시간 (ms): 15.003016800000001
```

- TEST CASE : 동일한 사용자에 대한 충전/결제 요청이 동시에 4건 발생하는 경우 모두 성공해야 한다. (충전 2건, 결제 2건)

```
전체 테스트 수행 시간 (ms): 19
최소 소요 작업 시간 (ms): 14
최대 소요 작업 시간 (ms): 17
평균 소요 작업 시간 (ms): 16.1384585
```

<br>

### 해결방안 3 - 분산락 (Distributed Lock) - Redission

---
- 구현 난이도 : `중간`
- 여러 인스턴스 간에 동시성 문제를 해결할 수 있다.
- 락을 점유해야 트랜잭션이 시작되기 때문에 사용자가 몰리는 충전 요청의 경우 DB 부하를 줄일 수 있다.
- 사용자 포인트에 대한 동시 요청이 거의 발생할 경우가 없기 때문에 불필요한 자원 낭비가 발생할 수 있다.

### 테스트 수행 결과
- TEST CASE : 동일한 사용자에 대한 충전 요청이 동시에 5건 발생하는 경우 모두 성공해야 한다.

```
전체 테스트 수행 시간 (ms): 47
최소 소요 작업 시간 (ms): 29
최대 소요 작업 시간 (ms): 46
평균 소요 작업 시간 (ms): 37.3099498
```

- TEST CASE : 동일한 사용자에 대한 충전/결제 요청이 동시에 4건 발생하는 경우 모두 성공해야 한다. (충전 2건, 결제 2건)

```
전체 테스트 수행 시간 (ms): 40
최소 소요 작업 시간 (ms): 26
최대 소요 작업 시간 (ms): 38
평균 소요 작업 시간 (ms): 32.32665625
```

<br>


### 테스트 수행 시간 한 눈에 보기
1. TEST CASE : 동일한 사용자에 대한 충전 요청이 동시에 5건 발생하는 경우 모두 성공해야 한다.

| 해결방안 | 전체 테스트 수행 시간 (ms) | 최소 소요 작업 시간 (ms) | 최대 소요 작업 시간 (ms) | 평균 소요 작업 시간 (ms) |
| --- | --- |---| --- | --- |
| 낙관적 락 | 346 | 20 | 345 | 173.01646680000002 |
| 비관적 락 | 17 | 12 | 16 | 15.003016800000001 |
| 분산락 | 47 | 29 | 46 | 37.3099498 |

2. TEST CASE : 동일한 사용자에 대한 충전/결제 요청이 동시에 4건 발생하는 경우 모두 성공해야 한다. (충전 2건, 결제 2건)

| 해결방안 | 전체 테스트 수행 시간 (ms) | 최소 소요 작업 시간 (ms) | 최대 소요 작업 시간 (ms) | 평균 소요 작업 시간 (ms) |
| --- | --- | --- | --- | --- |
| 낙관적 락 | 238 | 20 | 237 | 129.57480175 |
| 비관적 락 | 19 | 14 | 17 | 16.1384585 |
| 분산락 | 40 | 26 | 38 | 32.32665625 |

<br>

### 결론(의사결정)

`비관적 락`을 사용하여 동시성 문제를 해결
- 낙관적 락을 사용할 경우 재처리 로직이 필요하며, 요청이 많아질 경우 제대로 처리되지 않을 가능성이 있다. 또한 재시도 로직을 통해 성공할 때까지 요청을 반복하게 되면 성능이 저하될 수 있다.
  - 이는 테스트 결과에서도 확인할 수 있었다. 낙관적 락을 사용할 경우, 비관적 락에 비해 평균 소요 작업 시간이 더 길었다.
- 비관적 락을 사용할 경우 모두 성공 처리를 보장할 수 있으며, 요청이 많아질 경우 락을 대기하는 시간이 길어질 수 있지만 발생할 가능성이 낮기 때문에 성능 저하가 크지 않을 것이라고 판단된다.
- 또한 비관적 락을 사용할 경우 데이터 정합성을 보장할 수 있으며, 잔액 충전 및 결제 요청이 동시에 발생할 때 모두 성공 처리를 보장할 수 있다.
- 분산락의 경우 여러 인스턴스 간에 동시성 문제를 해결할 수 있지만, 사용자 포인트에 대한 동시 요청이 거의 발생할 경우가 없기 때문에 불필요한 자원 낭비가 발생할 수 있다. (오버 엔지니어링이라고 판단됨)

---

## 3) 좌석 예약 건 결제
- 시나리오: `동일한 예약 건에 대해 다수의 결제 요청이 동시에 발생한다.`
- 발생 가능성 : `낮음`
- 재처리 필요 여부 : `불필요`
- 동시성 이슈: `중복 결제가 발생할 수 있다.`

### 해결방안 1 - 낙관적 락 (Optimistic Lock)

---
- 구현 난이도 : `쉬움`
- 하나의 예약 건은 한 번만 결제되어야 하므로 실패된 요청은 재처리할 필요가 없다.
- 잦은 충돌이 발생하는 경우에는 트랜잭션 롤백 자원이 낭비될 수 있다. 하지만 좌석 예약 건 결제의 경우 충돌이 발생할 가능성이 낮다.
- 좌석 예약 여부를 미리 알지 못하고 커밋 시점에 확인할 수 있다.


### 테스트 수행 결과
- TEST CASE : 동일한 콘서트 예약 건에 대해 3개의 결제 요청이 동시에 발생하는 경우 하나의 요청만 성공하고 나머지는 실패해야 한다.
```
전체 테스트 수행 시간 (ms): 31
최소 소요 작업 시간 (ms): 24
최대 소요 작업 시간 (ms): 30
평균 소요 작업 시간 (ms): 27.59645833333333
```

<br>

### 해결방안 2 - 비관적 락 (Pessimistic Lock)

---
- 구현 난이도 : `쉬움`
- X-LOCK 을 사용하여 동시성 문제를 해결
- 읽기 작업에도 락을 걸기 때문에 성능 저하가 발생할 수 있다.
- 하나의 요청만 성공해야 하므로 불필요한 대기 시간을 가질 수 있다.
- DB 커넥션을 점유하는 시간이 길어질 수 있다.


### 테스트 수행 결과
- TEST CASE : 동일한 콘서트 예약 건에 대해 3개의 결제 요청이 동시에 발생하는 경우 하나의 요청만 성공하고 나머지는 실패해야 한다.
```
전체 테스트 수행 시간 (ms): 28
최소 소요 작업 시간 (ms): 24
최대 소요 작업 시간 (ms): 27
평균 소요 작업 시간 (ms): 26.534472
```

<br>

### 해결방안 3 - 분산락 (Distributed Lock) - Redission

---
- 구현 난이도 : `중간`
- reservationId 를 키로 사용하여 분산락을 사용하여 동시성 문제를 해결
- 락을 점유해야 트랜잭션이 시작되기 때문에 사용자가 몰리는 결제 요청의 경우 DB 부하를 줄일 수 있다.
- reservation 의 상태가 변경되는 시나리오 많으므로 분산락을 사용하여 동시성 문제를 해결할 수 있다.
  - 예약 취소, 결제, 부분 취소 등 다양한 시나리오에서 결제 상태 변경에 대한 동시성 문제가 발생할 수 있으므로 분산락을 사용하여 동시성 문제를 해결할 수 있다.


### 테스트 수행 결과
- TEST CASE : 동일한 콘서트 예약 건에 대해 3개의 결제 요청이 동시에 발생하는 경우 하나의 요청만 성공하고 나머지는 실패해야 한다.
```
전체 테스트 수행 시간 (ms): 59
최소 소요 작업 시간 (ms): 50
최대 소요 작업 시간 (ms): 59
평균 소요 작업 시간 (ms): 55.325833333333335
```

<br>

### 테스트 수행 시간 한 눈에 보기
| 해결방안 | 전체 테스트 수행 시간 (ms) | 최소 소요 작업 시간 (ms) | 최대 소요 작업 시간 (ms) | 평균 소요 작업 시간 (ms) |
| --- | --- | --- | --- | --- |
| 낙관적 락 | 31 | 24 | 30 | 27.59645833333333 |
| 비관적 락 | 28 | 24 | 27 | 26.534472 |
| 분산락 | 59 | 50 | 59 | 55.325833333333335 |

<br>

### 결론(의사결정)

`분산 락`을 사용하여 동시성 문제를 해결
- 좌석 예약 결제뿐만 아니라, 예약 취소, 부분 취소 등 다양한 시나리오에서 결제 상태 변경에 대한 동시성 문제가 발생할 수 있으므로, 단순한 방법보다 더 Robust한 분산 락을 사용하여 이러한 문제를 해결할 수 있다.
- 분산 락은 다양한 시나리오에 대응할 수 있는 유연성을 제공하며, 여러 인스턴스 간의 동기화를 쉽게 구현할 수 있다.
- 테스트 결과를 보면, 분산 락을 이용해도 소요 시간이 많이 차이나지 않아 비슷한 성능을 보여준다.
- 비관적 락에 비해 DB 커넥션을 점유하는 시간이 없기 때문에 성능 저하를 최소화할 수 있다.

---

## 3. 참고 문헌
- [낙관적 락(Optimistic Locking)과 비관적 락(Pessimistic Locking)의 차이](https://sabarada.tistory.com/175)
- [풀필먼트 입고 서비스팀에서 분산락을 사용하는 방법 - Spring Redisson](https://helloworld.kurly.com/blog/distributed-redisson-lock)
- [(Spring Framework)spring retry 로 간편하게 재수행 로직 추가하기](https://hvho.github.io/2021-12-05/spring-retry)